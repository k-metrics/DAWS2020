---
title: "Covid19, Japan"
output:
  html_document:
    df_print: paged
    theme: cerulean
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
require(tidyverse)
require(jsonlite)
```

# Import

## Covid19 Data
```{r, echo=FALSE}
path <- "https://raw.githubusercontent.com/reustle/covid19japan-data/master/"
path <- paste0(path, "docs/patient_data/")

data_at <- readr::read_lines(paste0(path, "latest.json")) %>% 
  stringr::str_sub(start = 1L, end = -6L)
```

[Covid19 Japan](https://covid19japan.com/)の公開データ（`r data_at`付）を使います。
```{r, echo=FALSE}
df <- path %>% 
  paste0("latest.json") %>% 
  readr::read_lines() %>% 
  paste0(path, .) %>% 
  jsonlite::fromJSON()

df
```

　  

## Area Data
都道府県と地方区分に関するデータは自作データで都道府県コード（`pcode`）順で各区分を因子化してあります。
```{r, echo=FALSE, message=FALSE}
prefs <- "https://gist.githubusercontent.com/k-metrics/9f3fc18e042850ff24ad9676ac34764b/raw/bcf237d21ace39eb74adafe76d6cb1d5c463d31e/pref_utf8.csv" %>% 
  readr::read_csv() %>% 
  dplyr::rename(pcode = `コード`) %>% 
  dplyr::mutate(pref = stringr::str_to_title(pref),
                pcode = forcats::fct_inorder(pcode),
                fct_pref = forcats::fct_inorder(pref),
                `都道府県` = forcats::fct_inorder(`都道府県`),
                `八地方区分` = forcats::fct_inorder(`八地方区分`),
                `広域圏` = forcats::fct_inorder(`広域圏`),
                `通俗的区分` = forcats::fct_inorder(`通俗的区分`))

prefs
```

　  

# Data Wrangling

## Summarize
オリジナルのデータがどのようになっているか`skimr`パッケージを用いてサマライズしてみます。元がJSON形式なので、読み込んだ直後は殆どの変量（フィーチャー）が文字型になっているのと欠損値が多いことが分かります。
```{r}
df %>% 
  skimr::skim()
```

　  

## Transform
各変量（フィーチャー）を適切な形式に変換し、地域区分でも分析できるように都道府県データと結合します。
```{r}
x <- df %>% 
  dplyr::mutate(dateAnnounced = lubridate::as_date(dateAnnounced),
                ageBracket = forcats::as_factor(ageBracket),
                gender = forcats::as_factor(gender),
                patientStatus = forcats::as_factor(patientStatus),
                residence = forcats::as_factor(residence),
                cluster = dplyr::if_else(!is.na(knownCluster), TRUE, FALSE)) %>% 
  dplyr::select(dateAnnounced, ageBracket, gender, detectedPrefecture,
                patientStatus, knownCluster, cluster) %>% 
  dplyr::left_join(prefs, by = c("detectedPrefecture" = "pref"))

x
x %>% 
  skimr::skim()
```

　  
文字型を因子型に変換するだけでも、変量（フィーチャー）内の水準の比率が大まかにつかめるようになります。  
例えば、年代別の陽性判定者数は20代が最も多く、続いて、30代、40代と働き盛りの世代に多いことが分かります。また、都道府県別では、東京、大阪、神奈川、愛知と成っていますが、地方区分別では、以外にも関東、大阪の次に九州がきていることが分かります。

　  

# Visualizing

## 全体傾向

```{r, include=FALSE}
# 欠損日を埋めるためにジョインするためのカレンダー
date <- x %>% 
  with(seq(range(dateAnnounced)[1], range(dateAnnounced)[2], by = "day")) %>% 
  as.data.frame() %>% 
  dplyr::rename(date = 1)

# 同様の処理は以下の一行でもできる（rangeを使うか、min/maxを使うかは好み）
# x %>%
#   tidyr::complete(dateAnnounced = seq.Date(min(dateAnnounced),
#                                            max(dateAnnounced), by = "day"))
# x %>% with(range(dateAnnounced)) %>% diff()
```

```{r}
sec_scale <- 50

x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::mutate(n = tidyr::replace_na(n, 0)) %>% 
  dplyr::mutate(cum = cumsum(n),
                ma = zoo::rollmeanr(n, k = 7L, na.pad = TRUE)) %>%
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced)) + 
    ggplot2::geom_bar(ggplot2::aes(y = n), stat = "identity",
                      fill = "dark green", alpha = 0.5) + 
    ggplot2::geom_line(ggplot2::aes(y = cum / sec_scale),
                       colour = "dark green") +
    ggplot2::geom_line(ggplot2::aes(y = ma), colour = "dark red") + 
    ggplot2::scale_y_continuous(
      name = "陽性確定数（日別）・7日間移動平均（濃赤折線）",
      sec.axis = ggplot2::sec_axis(~ . * sec_scale,
                                    name = "累積陽性確定者数（折線）")
    ) +
    ggplot2::labs(title = paste0("Covid19, Japan（@", Sys.time(), "）"),
                  subtitle = "", x = "日付")

plotly::ggplotly()
```


### 地方区分別
都道府県別では区分が多すぎるので八地方区分別の積上げ棒グラフを描いてみます。サマリで見たように九州地方が以外にも多いことが読み取れます。
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::mutate(n = tidyr::replace_na(n, 0)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, fill = `八地方区分`)) + 
    ggplot2::geom_bar(ggplot2::aes(y = n), stat = "identity", alpha = 1.0) +
    ggplot2::scale_fill_brewer(palette = "Set1")
```

折線グラフで表示してみます。
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::mutate(n = tidyr::replace_na(n, 0)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, colour = `八地方区分`)) + 
    ggplot2::geom_line(ggplot2::aes(y = n)) +
    ggplot2::scale_colour_brewer(palette = "Set1")
```


　  
さらに分かりやすくするために関東、中部、近畿、九州の四地区を除く他の地区をその他としてまとめてみます。
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::mutate(`八地方区分` = forcats::fct_collapse(`八地方区分`,
                                                `その他地方` = c("北海道地方",
                                                          "東北地方",
                                                          "中国地方",
                                                          "四国地方"))) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::mutate(n = tidyr::replace_na(n, 0)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, fill = `八地方区分`)) + 
    ggplot2::geom_bar(ggplot2::aes(y = n), stat = "identity", alpha = 1.0) +
    ggplot2::scale_fill_brewer(palette = "Set1")
```


```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::mutate(`八地方区分` = forcats::fct_collapse(`八地方区分`,
                                                `その他地方` = c("北海道地方",
                                                          "東北地方",
                                                          "中国地方",
                                                          "四国地方"))) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::mutate(n = tidyr::replace_na(n, 0)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, colour = `八地方区分`)) + 
    ggplot2::geom_line(ggplot2::aes(y = n)) +
    ggplot2::scale_colour_brewer(palette = "Set1") +
    ggplot2::facet_wrap(~ `八地方区分`, ncol = 2)
```

```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::ungroup() %>% 
  tidyr::pivot_wider(names_from = `八地方区分`, values_from = n) %>% 
  dplyr::mutate_if(is.integer, list(~tidyr::replace_na(., 0L))) %>% 
  tidyr::pivot_longer(cols = -dateAnnounced,
                      names_to = "八地方区分", values_to = "n") %>% 
  dplyr::mutate(`八地方区分` = forcats::fct_relevel(`八地方区分`,
                                              "北海道地方", "東北地方",
                                              "関東地方", "中部地方",
                                              "近畿地方", "中国地方",
                                              "四国地方", "九州地方")) %>%
  dplyr::group_by(`八地方区分`) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, y = cum,
                               fill = `八地方区分`)) +
    ggplot2::geom_area(stat = "identity", alpha = 1,
                       position = ggplot2::position_stack(reverse = FALSE)) +
    ggplot2::scale_fill_brewer(palette = "Set3") +
    ggplot2::labs(title = paste0("Covid19（@", Sys.time(), "）"),
                  y = "累計人数")

```

　  
九州が8月頃から急増しているのは、県別に見ると福岡と沖縄での急増が原因と分かります。
```{r}
x %>% 
  dplyr::filter(`八地方区分` == "九州地方") %>% 
  dplyr::group_by(dateAnnounced, `都道府県`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::ungroup() %>% 
  tidyr::pivot_wider(names_from = `都道府県`, values_from = n) %>% 
  dplyr::mutate_if(is.integer, list(~tidyr::replace_na(., 0L))) %>% 
  tidyr::pivot_longer(cols = -dateAnnounced,
                      names_to = "都道府県", values_to = "n") %>% 
  dplyr::mutate(`都道府県` = forcats::fct_relevel(`都道府県`,
                                              "福岡県", "佐賀県", "長崎県",
                                              "熊本県", "大分県", "宮崎県",
                                              "鹿児島県", "沖縄県")) %>%
  dplyr::group_by(`都道府県`) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, y = cum,
                               fill = `都道府県`)) +
    ggplot2::geom_area(stat = "identity", alpha = 1,
                       position = ggplot2::position_stack(reverse = FALSE)) +
    ggplot2::scale_fill_brewer(palette = "Set3") +
    ggplot2::labs(title = paste0("Covid19, 九州地方（@", Sys.time(), "）"),
                  y = "累計人数")

```

　  

### クラスタ比率
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(`八地方区分`, cluster) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::pivot_wider(names_from = cluster, values_from = n) %>% 
  dplyr::mutate(ratio = (`TRUE` / (`TRUE` + `FALSE`) * 100) %>% round(1)) %>% 
  dplyr::rename(`地方` = `八地方区分`,
                `非クラスタ感染者` = `FALSE`, `クラスタ感染者` = `TRUE`,
                `クラスタ比率[%]` = ratio)
```



# Modeling

## 時系列（TS）分析
日毎の陽性判定者数を時系列データ形式に変換します。判定者数がゼロの日は報告されていないので、最初の陽性判定者が出た日から日日次のカレンダーデータを作成して結合してます。なお、時系列データ形式の周期については日次データなので7日間を周期として設定しておきます（考え方によっては約1ヶ月ごとで4週間=28日を周期にするのもありかと思います）。

```{r}
tmp <- x %>%
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced) %>% 
  dplyr::summarise(n = n()) %>% print() %>% 
  dplyr::rename(date = dateAnnounced) %>% 
  tidyr::complete(date = seq.Date(min(date), max(date), by = "day")) %>% print() %>% 
  tidyr::replace_na(list(n = 0L)) %>% print() %>% 
  dplyr::select(-date)

ts_x <- tmp %>%
  ts(frequency = 1)

tsw_x <- tmp %>%
  ts(frequency = 7)

tsm_x <- tmp %>%
  ts(frequency = 28)

```

```{r, eval=FALSE}
# ts_x <- x %>% 
#   dplyr::filter(!is.na(fct_pref)) %>% 
#   dplyr::group_by(dateAnnounced) %>% 
#   dplyr::summarise(n = n()) %>% 
#   dplyr::left_join(date, ., by = c("date" = "dateAnnounced")) %>% 
#   dplyr::mutate(n = tidyr::replace_na(n, 0L)) %>% 
#   dplyr::select(-date) %>%
#   ts(frequency = 1)
#   
# tsw_x <- x %>% 
#   dplyr::filter(!is.na(fct_pref)) %>% 
#   dplyr::group_by(dateAnnounced) %>% 
#   dplyr::summarise(n = n()) %>% 
#   dplyr::left_join(date, ., by = c("date" = "dateAnnounced")) %>% 
#   dplyr::mutate(n = tidyr::replace_na(n, 0L)) %>% 
#   dplyr::select(-date) %>%
#   ts(frequency = 7)
# 
# tsm_x <- x %>% 
#   dplyr::filter(!is.na(fct_pref)) %>% 
#   dplyr::group_by(dateAnnounced) %>% 
#   dplyr::summarise(n = n()) %>% 
#   dplyr::left_join(date, ., by = c("date" = "dateAnnounced")) %>% 
#   dplyr::mutate(n = tidyr::replace_na(n, 0L)) %>% 
#   dplyr::select(-date) %>%
#   ts(frequency = 28)
```

時系列データに変換したものをプロットすると可視化の項でプロットした棒グラフと同じ形のグラフになることが分かります。
```{r}
ts_x %>% 
  plot()
tsw_x %>% 
  plot()
tsm_x %>% 
  plot()
```

上記からトレンド（長期的傾向）を除いたグラフ。デフォルト指定なので`lag = 1`
```{r}
ts_x %>% 
  base::diff() %>% 
  plot()

tsw_x %>% 
  base::diff() %>% 
  plot()

tsm_x %>% 
  base::diff() %>% 
  plot()
```

トレンド、季節変動（周期変動）、非周期変動に分解した場合。`frequency = 1`では分解できない点に注意。
```{r}
tsw_x %>% 
  stats::decompose() %>% 
  plot()

tsm_x %>% 
  stats::decompose() %>% 
  plot()
```

トレンドだけを抜き出してみる。
```{r}
tsw_x %>% 
  stats::decompose() %>% 
  .$x %>% 
  plot(ylim = c(0, 1500))

par(new = TRUE)

tsw_x %>% 
  stats::decompose() %>% 
  .$trend %>% 
  plot(ylim = c(0, 1500), col = "dark green", lwd = 3)

par(new = FALSE)
```

```{r}
tsm_x %>% 
  stats::decompose() %>% 
  .$x %>% 
  plot(ylim = c(0, 1500))

par(new = TRUE)

tsm_x %>% 
  stats::decompose() %>% 
  .$trend %>% 
  plot(ylim = c(0, 1500), col = "blue", lwd = 3)

par(new = FALSE)

# tsm_x %>% 
#   stats::decompose() %>% 
#   .$trend %>% 
#   plot()
```


スペクトル密度の推定。何を意味するのかよく分からない。
```{r}
ts_x %>% 
  spec.pgram()

tsw_x %>% 
  spec.pgram()

tsm_x %>% 
  spec.pgram()

```

自己回帰によるスペクトラム解析
```{r}
spectrum(ts_x, method="ar")
spectrum(tsw_x, method="ar")
spectrum(tsm_x, method="ar")
```


# Infer

## ARIMA Model
ARIMA（Auto Regressive Integrated Moving Average, 自己回帰和分移動平均）モデルによる予測を行ってみます。予測に必要なパラメータはステップワイズにより自動的に最適なものが選択されます。
```{r}
ts_x %>% 
  forecast::auto.arima() %>% 
  forecast::forecast() %>% 
  plot()

tsw_x %>% 
  forecast::auto.arima() %>% 
  forecast::forecast() %>% 
  plot()

tsm_x %>% 
  forecast::auto.arima() %>% 
  forecast::forecast() %>% 
  plot()
```

