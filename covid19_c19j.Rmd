---
title: "Covid19, Japan"
output:
  html_document:
    code_folding : hide
    df_print: paged
    theme: cerulean
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
require(tidyverse)
require(jsonlite)
```


# Covid19 Japan
[Covid19 Japan](covid19japan.com)が独自に収集している陽性確定者単位のデータ。ソースとデータは全て[GitHub](https://github.com/reustle/covid19japan)にて公開されているが、データはJSON形式である点に注意。発表後に修正されたレコード（インスタンス）は削除されれずにステータスなどが変更されているだけなので、「レコード数 $\neq$ 累計陽性確定者」である点に注意。

　  

## Import
[Covid19 Japan](covid19japan.com)が[GitHub](https://github.com/reustle/covid19japan)で公開しているデータはJSOM形式のため、また、最新データがインデックスで示されているため、読み込むには少し工夫が必要である。


### Patient Data
陽性者単位のデータ。
```{r}
path <- "https://raw.githubusercontent.com/reustle/covid19japan-data/master/docs/patient_data/"

data_at <- readr::read_lines(paste0(path, "latest.json")) %>% 
  stringr::str_sub(start = 1L, end = -6L)

df <- path %>% 
  paste0("latest.json") %>% 
  readr::read_lines() %>% 
  paste0(path, .) %>% 
  jsonlite::fromJSON()

df
```

　  

### Summary Data
陽性者、死亡者、重症者などのデータは、陽性者単位のデータとは別のファイル（JSON形式）に集計されている。ただし、ファイル中に4種類のデータが含まれている点に注意。
```{r}
path <- "https://raw.githubusercontent.com/reustle/covid19japan-data/master/docs/summary/"

# data_at <- readr::read_lines(paste0(path, "latest.json")) %>% 
#   stringr::str_sub(start = 1L, end = -6L)

df_s <- path %>% 
  paste0("latest.json") %>% 
  readr::read_lines() %>% 
  paste0(path, .) %>% 
  jsonlite::fromJSON()
```

#### 都道府県単位集計
厳密には都道府県＋空港検疫・ダイヤモンドプリンセス・長崎クルーズ船・その他の区分になっている。一部の変量（フィーチャー）がネストされている。
```{r}
df_s$prefectures
```

　  

#### 地方単位集計
いわゆる八地方区分単位で集計されているデータ。こちらも都道府県単位集計と同様に一部の変量（フィーチャー）がネストされている。
```{r}
df_s$regions
```

　  

#### 日次集計
これが厚生労働省の日次集計データと同様の集計データ。一つのデータフレームにまとめられているが、最初の行（インスタンス、レコード）の日付がおかしい点に注意。
```{r}
df_s$daily
```

　  

#### 更新日時
集計データファイル（JSON形式）の更新日時が記録されている。
```{r}
df_s$daily
```

　  

### Area Data
Covid19 Japanのデータは陽性者単位のデータであるため、報告主題である都道府県のデータが含まれているので、地域・地方ごとの分類を行うために都道府県データを作成した。この都道府県データは[Gist](https://gist.github.com/k-metrics/9f3fc18e042850ff24ad9676ac34764b)にて公開しているので、使いたい場合はご自由に。
```{r, echo=FALSE, message=FALSE}
prefs <- "https://gist.githubusercontent.com/k-metrics/9f3fc18e042850ff24ad9676ac34764b/raw/bcf237d21ace39eb74adafe76d6cb1d5c463d31e/pref_utf8.csv" %>% 
  readr::read_csv() %>% 
  dplyr::rename(pcode = `コード`) %>% 
  dplyr::mutate(pref = stringr::str_to_title(pref),
                pcode = forcats::fct_inorder(pcode),
                fct_pref = forcats::fct_inorder(pref),
                `都道府県` = forcats::fct_inorder(`都道府県`),
                `八地方区分` = forcats::fct_inorder(`八地方区分`),
                `広域圏` = forcats::fct_inorder(`広域圏`),
                `通俗的区分` = forcats::fct_inorder(`通俗的区分`))

prefs
```

　  

## Wrangle (tidy and transform)

### Summarize
まず、オリジナルのデータがどのようになっているか`skimr`パッケージを用いてサマライズしておく。
```{r}
df %>% 
  skimr::skim()
```

　  
元がJSON形式なので、読み込んだ直後は殆どの変量（フィーチャー）が文字型になっていることが分かる。また、意外と欠損が多いことも分かるので、欠損が非常に多い変量は除いておくことにする。  

　  

### Transform
各変量（フィーチャー）を適切な形式に変換し、地域区分でも分析できるように都道府県データと結合します。
```{r}
x <- df %>% 
  dplyr::select(patientId, date = dateAnnounced, gender,
                pref = detectedPrefecture, patientStatus, knownCluster,
                confirmedPatient, charterFlightPassenger,
                cruisePassengerDisembarked, ageBracket,
                deceasedDate, deceasedReportedDate) %>% 
  dplyr::filter(confirmedPatient == TRUE) %>% 
  dplyr::mutate(date = lubridate::as_date(date),
                gender = forcats::as_factor(gender),
                patientStatus = forcats::as_factor(patientStatus),
                cluster = dplyr::if_else(!is.na(knownCluster), TRUE, FALSE),
                ageBracket = forcats::as_factor(ageBracket),
                deceasedDate = lubridate::as_date(deceasedDate),
                deceasedReportedDate = lubridate::as_date(deceasedReportedDate)) %>% 
    dplyr::left_join(prefs, by = c("pref" = "pref"))

x
x %>% 
  skimr::skim()
```

　  
文字型を因子型に変換するだけでも大まかな傾向が見える。例えば

* 年齢別で見ると20代、30代、年齢非回答、40代の順に陽性者が多い
* 都道府県では人口の多い、東京、大阪、神奈川、愛知の順
* 地方区分で見ると関東、近畿、九州、中部となっており九州地方が以外と多い

ことが読める。  

`parientStatus`は症状（状態）と状況が混在しているため、分かりにくいが以下の通りである。なお、`Unspecified`とは別に欠損値（`NA`）もある。

levels                  | 意味
------------------------|----------------
Hospitalized            | 入院中
Critical (Hospitalized) | 重症（入院中）
Home Quarantine         | 自宅療養中
Hotel Quarantine        | ホテル療養中
Recoverd                | 回復
Discharged              | 退院済
Deceased                | 死亡
Unspecified             | 詳細不明

　  

### Transform (daily data)

#### 陽性者数
陽性者の日次、前日比、累計を作成する。
```{r}
x_n <- x %>% 
  dplyr::group_by(date) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::complete(date = seq.Date(from = min(date), to = max(date), by = "day"),
                  fill = list(n = 0L)) %>% 
  dplyr::mutate(diff = n - dplyr::lag(n, default = 0L),
                cum = cumsum(n))
x_n
```

　  

#### 死亡者数
同様に死亡者の日次、前日比、累計を求めたいが、`patientStatus`を見る限り
```{r}
x %>% 
  dplyr::filter(patientStatus == "Deceased") %>% 
  dplyr::group_by(deceasedDate) %>% 
  dplyr::summarise(dead = n()) %>% 
  dplyr::rename(date = deceasedDate) %>% 
  tidyr::complete(date = seq.Date(from = min(date), to = max(date), by = "day"),
                  fill = list(dead = 0L)) %>% 
  dplyr::mutate(diff_dead = dead - dplyr::lag(dead, default = 0L),
                cum_dead = cumsum(dead))
  
```


　  

# Visualizing



```{r}
sec_scale <- 50

x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::complete(dateAnnounced = seq.Date(from = min(dateAnnounced),
                                           to = max(dateAnnounced),
                                           by = "day"),
                  fill = list(n = 0L)) %>% 
  dplyr::mutate(cum = cumsum(n),
                ma = zoo::rollmeanr(n, k = 7L, na.pad = TRUE)) %>%
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced)) + 
    ggplot2::geom_bar(ggplot2::aes(y = n), stat = "identity",
                      fill = "dark green", alpha = 0.5, width = 1.0) + 
    ggplot2::geom_line(ggplot2::aes(y = cum / sec_scale),
                       colour = "dark green") +
    ggplot2::geom_line(ggplot2::aes(y = ma), colour = "dark red") + 
    ggplot2::scale_y_continuous(
      name = "陽性確定数（日別）・7日間移動平均（濃赤折線）",
      sec.axis = ggplot2::sec_axis(~ . * sec_scale,
                                    name = "累積陽性確定者数（折線）")
    ) +
    ggplot2::labs(title = paste0("Covid19, Japan（@", Sys.time(), "）"),
                  subtitle = "", x = "日付")

plotly::ggplotly()
```


### 地方区分別
都道府県別では区分が多すぎるので八地方区分別の積上げ棒グラフを描いてみます。サマリで見たように九州地方が以外にも多いことが読み取れます。
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::complete(dateAnnounced = seq.Date(from = min(dateAnnounced),
                                           to = max(dateAnnounced),
                                           by = "day"),
                  fill = list(n = 0L)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, fill = `八地方区分`)) + 
    ggplot2::geom_bar(ggplot2::aes(y = n), stat = "identity", alpha = 1.0) +
    ggplot2::scale_fill_brewer(palette = "Set1")
```

折線グラフで表示してみます。
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::complete(dateAnnounced = seq.Date(from = min(dateAnnounced),
                                           to = max(dateAnnounced),
                                           by = "day"),
                  fill = list(n = 0L)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, colour = `八地方区分`)) + 
    ggplot2::geom_line(ggplot2::aes(y = n)) +
    ggplot2::geom_point(ggplot2::aes(y = n), size = 1) + 
    ggplot2::scale_colour_brewer(palette = "Set1")
```


　  
さらに分かりやすくするために関東、中部、近畿、九州の四地区を除く他の地区をその他としてまとめてみます。
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::mutate(`八地方区分` = forcats::fct_collapse(`八地方区分`,
                                                `その他地方` = c("北海道地方",
                                                          "東北地方",
                                                          "中国地方",
                                                          "四国地方"))) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::complete(dateAnnounced = seq.Date(from = min(dateAnnounced),
                                           to = max(dateAnnounced),
                                           by = "day"),
                  fill = list(n = 0L)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, fill = `八地方区分`)) + 
    ggplot2::geom_bar(ggplot2::aes(y = n), stat = "identity", alpha = 1.0) +
    ggplot2::scale_fill_brewer(palette = "Set1")
```


```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::mutate(`八地方区分` = forcats::fct_collapse(`八地方区分`,
                                                `その他地方` = c("北海道地方",
                                                          "東北地方",
                                                          "中国地方",
                                                          "四国地方"))) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::complete(dateAnnounced = seq.Date(from = min(dateAnnounced),
                                           to = max(dateAnnounced),
                                           by = "day"),
                  fill = list(n = 0L)) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, colour = `八地方区分`)) + 
    ggplot2::geom_line(ggplot2::aes(y = n)) +
    ggplot2::scale_colour_brewer(palette = "Set1") +
    ggplot2::facet_wrap(~ `八地方区分`, ncol = 2)
```

```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced, `八地方区分`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::ungroup() %>% 
  tidyr::pivot_wider(names_from = `八地方区分`, values_from = n) %>% 
  dplyr::mutate_if(is.integer, list(~tidyr::replace_na(., 0L))) %>% 
  tidyr::pivot_longer(cols = -dateAnnounced,
                      names_to = "八地方区分", values_to = "n") %>% 
  dplyr::mutate(`八地方区分` = forcats::fct_relevel(`八地方区分`,
                                              "北海道地方", "東北地方",
                                              "関東地方", "中部地方",
                                              "近畿地方", "中国地方",
                                              "四国地方", "九州地方")) %>%
  dplyr::group_by(`八地方区分`) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, y = cum,
                               fill = `八地方区分`)) +
    ggplot2::geom_area(stat = "identity", alpha = 1,
                       position = ggplot2::position_stack(reverse = FALSE)) +
    ggplot2::scale_fill_brewer(palette = "Set3") +
    ggplot2::labs(title = paste0("Covid19（@", Sys.time(), "）"),
                  y = "累計人数")

```

　  
九州が8月頃から急増しているのは、県別に見ると福岡と沖縄での急増が原因と分かります。
```{r}
x %>% 
  dplyr::filter(`八地方区分` == "九州地方") %>% 
  dplyr::group_by(dateAnnounced, `都道府県`) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::ungroup() %>% 
  tidyr::pivot_wider(names_from = `都道府県`, values_from = n) %>% 
  dplyr::mutate_if(is.integer, list(~tidyr::replace_na(., 0L))) %>% 
  tidyr::pivot_longer(cols = -dateAnnounced,
                      names_to = "都道府県", values_to = "n") %>% 
  dplyr::mutate(`都道府県` = forcats::fct_relevel(`都道府県`,
                                              "福岡県", "佐賀県", "長崎県",
                                              "熊本県", "大分県", "宮崎県",
                                              "鹿児島県", "沖縄県")) %>%
  dplyr::group_by(`都道府県`) %>% 
  dplyr::mutate(cum = cumsum(n)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = dateAnnounced, y = cum,
                               fill = `都道府県`)) +
    ggplot2::geom_area(stat = "identity", alpha = 1,
                       position = ggplot2::position_stack(reverse = FALSE)) +
    ggplot2::scale_fill_brewer(palette = "Set3") +
    ggplot2::labs(title = paste0("Covid19, 九州地方（@", Sys.time(), "）"),
                  y = "累計人数")

```

　  

### クラスタ比率
```{r}
x %>% 
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(`八地方区分`, cluster) %>% 
  dplyr::summarise(n = n()) %>% 
  tidyr::pivot_wider(names_from = cluster, values_from = n) %>% 
  dplyr::mutate(ratio = (`TRUE` / (`TRUE` + `FALSE`) * 100) %>% round(1)) %>% 
  dplyr::rename(`地方` = `八地方区分`,
                `非クラスタ感染者` = `FALSE`, `クラスタ感染者` = `TRUE`,
                `クラスタ比率[%]` = ratio)
```



# Modeling

## 時系列（TS）分析
日毎の陽性判定者数を時系列データ形式に変換します。判定者数がゼロの日は報告されていないので、最初の陽性判定者が出た日から日日次のカレンダーデータを作成して結合してます。なお、時系列データ形式の周期については日次データなので7日間を周期として設定しておきます（考え方によっては約1ヶ月ごとで4週間=28日を周期にするのもありかと思います）。

```{r}
tmp <- x %>%
  dplyr::filter(!is.na(fct_pref)) %>% 
  dplyr::group_by(dateAnnounced) %>% 
  dplyr::summarise(n = n()) %>% print() %>% 
  dplyr::rename(date = dateAnnounced) %>% 
  tidyr::complete(date = seq.Date(min(date), max(date), by = "day"),
                  fill = list(n = 0L)) %>% print() %>% 
  # tidyr::replace_na(list(n = 0L)) %>% print() %>% 
  dplyr::select(-date)

ts_x <- tmp %>%
  ts(frequency = 1)

tsw_x <- tmp %>%
  ts(frequency = 7)

tsm_x <- tmp %>%
  ts(frequency = 28)
```

```{r, eval=FALSE}
# ts_x <- x %>% 
#   dplyr::filter(!is.na(fct_pref)) %>% 
#   dplyr::group_by(dateAnnounced) %>% 
#   dplyr::summarise(n = n()) %>% 
#   dplyr::left_join(date, ., by = c("date" = "dateAnnounced")) %>% 
#   dplyr::mutate(n = tidyr::replace_na(n, 0L)) %>% 
#   dplyr::select(-date) %>%
#   ts(frequency = 1)
#   
# tsw_x <- x %>% 
#   dplyr::filter(!is.na(fct_pref)) %>% 
#   dplyr::group_by(dateAnnounced) %>% 
#   dplyr::summarise(n = n()) %>% 
#   dplyr::left_join(date, ., by = c("date" = "dateAnnounced")) %>% 
#   dplyr::mutate(n = tidyr::replace_na(n, 0L)) %>% 
#   dplyr::select(-date) %>%
#   ts(frequency = 7)
# 
# tsm_x <- x %>% 
#   dplyr::filter(!is.na(fct_pref)) %>% 
#   dplyr::group_by(dateAnnounced) %>% 
#   dplyr::summarise(n = n()) %>% 
#   dplyr::left_join(date, ., by = c("date" = "dateAnnounced")) %>% 
#   dplyr::mutate(n = tidyr::replace_na(n, 0L)) %>% 
#   dplyr::select(-date) %>%
#   ts(frequency = 28)
```

時系列データに変換したものをプロットすると可視化の項でプロットした棒グラフと同じ形のグラフになることが分かります。
```{r}
ts_x %>% 
  plot()
tsw_x %>% 
  plot()
tsm_x %>% 
  plot()
```

上記からトレンド（長期的傾向）を除いたグラフ。デフォルト指定なので`lag = 1`
```{r}
ts_x %>% 
  base::diff() %>% 
  plot()

tsw_x %>% 
  base::diff() %>% 
  plot()

tsm_x %>% 
  base::diff() %>% 
  plot()
```

トレンド、季節変動（周期変動）、非周期変動に分解した場合。`frequency = 1`では分解できない点に注意。
```{r}
tsw_x %>% 
  stats::decompose() %>% 
  plot()

tsm_x %>% 
  stats::decompose() %>% 
  plot()
```

トレンドだけを抜き出してみる。
```{r}
tsw_x %>% 
  stats::decompose() %>% 
  .$x %>% 
  plot(ylim = c(0, 1500))

par(new = TRUE)

tsw_x %>% 
  stats::decompose() %>% 
  .$trend %>% 
  plot(ylim = c(0, 1500), col = "dark green", lwd = 3)

par(new = FALSE)
```

```{r}
tsm_x %>% 
  stats::decompose() %>% 
  .$x %>% 
  plot(ylim = c(0, 1500))

par(new = TRUE)

tsm_x %>% 
  stats::decompose() %>% 
  .$trend %>% 
  plot(ylim = c(0, 1500), col = "blue", lwd = 3)

par(new = FALSE)

# tsm_x %>% 
#   stats::decompose() %>% 
#   .$trend %>% 
#   plot()
```


スペクトル密度の推定。何を意味するのかよく分からない。
```{r}
ts_x %>% 
  spec.pgram()

tsw_x %>% 
  spec.pgram()

tsm_x %>% 
  spec.pgram()

```

自己回帰によるスペクトラム解析
```{r}
spectrum(ts_x, method="ar")
spectrum(tsw_x, method="ar")
spectrum(tsm_x, method="ar")
```


# Infer

## ARIMA Model
ARIMA（Auto Regressive Integrated Moving Average, 自己回帰和分移動平均）モデルによる予測を行ってみます。予測に必要なパラメータはステップワイズにより自動的に最適なものが選択されます。
```{r}
ts_x %>% 
  forecast::auto.arima() %>% 
  forecast::forecast() %>% 
  plot()

tsw_x %>% 
  forecast::auto.arima() %>% 
  forecast::forecast() %>% 
  plot()

tsm_x %>% 
  forecast::auto.arima() %>% 
  forecast::forecast() %>% 
  plot()
```

