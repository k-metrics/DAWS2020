---
title: "tidyrに隠された便利な関数"
output:
  html_document:
    df_print: paged
    theme: cerulean
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
---

```{r setup, message=FALSE, echo=FALSE}
require(tidyverse)
require(lubridate)
```

`tidyr`パッケージの紹介では`pivot_longer.wider`や`separate/unite`とい関数ばかりが紹介されています。しかし、あまり紹介されない関数の中には非常に便利な関数が用意されているので使わない手はありません。本日はこれらを紹介していきます。  

　  

# 欠損と欠落
データ分析において「データの一部がない」というケースは多々存在します。逆にいえば完全なデータになっている場合の方が稀です。データの一部がないというのは以下の二つの場合が考えられます。

+ 観測値の一部が取れていない（セルに抜けがある）
* 観測記録の一部がない（行に抜けがある）

ここでは、この二つを区別するために前者を「欠損（`NA`）」、後者を「欠落」と呼びます。欠落は観測記録が取れなかった（欠損した）というよりは、観測値が全てないので記録を省略する、とか、観測値がゼロなので記録を省略するというようなことを暗黙的に示している場合があります。  
このような暗黙の欠落は可視化や分析処理の都合上、明示的な欠落に変換しないと正しく処理できない場合があります。

　  

## 欠損の例
まず、Rにおける欠損とはどのようなものなのかを確認しましょう。ニューヨークの大気観測データ（`airauality`データセット）は、1973年の5月1日から9月30日までの5ヶ月間（153日間）の観測データが収められています。このデータセットでは個々の観測値（変量）が部分的に欠損（値が`NA`になっている）していますが、日々の記録（インスタンス）自体は欠落していません。
```{r, echo=FALSE}
airquality
```

　  

## 欠落の例
一方、新型コロナウィルス検査の陽性確定者数データのように確定者数がゼロの日は報告なし、つまり、人数の変量（フィーチャー）はゼロなので記録（インスタンス）を省略した暗黙的な欠落を含むデータとなっています。例えば下表の2020年1月16日〜1月23日の間、1月27日、2月2日〜3日は暗黙的な欠落になっています。
```{r, echo=FALSE, message=FALSE}
path <- "https://raw.githubusercontent.com/reustle/covid19japan-data/master/"
path <- paste0(path, "docs/patient_data/")

df <- path %>% 
  paste0("latest.json") %>% 
  readr::read_lines() %>% 
  paste0(path, .) %>% 
  jsonlite::fromJSON() %>% 
  dplyr::group_by(dateAnnounced) %>% 
  dplyr::summarise(n = n()) %>% 
  dplyr::ungroup() %>% 
  dplyr::slice(1:10) %>% 
  dplyr::mutate(date = lubridate::as_date(dateAnnounced)) %>% 
  dplyr::select(date, n)

df
```

　  

# 暗黙的欠落の明示化
上表を折線グラフ化した場合、本来であれば暗黙的な欠落は$0$（ゼロ）と表示されなければなりません。また、欠落している日付を飛ばさずに線を結ばなければ正しくグラフとは言えません。
```{r}
df %>% 
  ggplot2::ggplot(ggplot2::aes(x = date, y = n)) + 
    ggplot2::geom_line()
```

　  

## 【質問】
このような暗黙的な欠落を明示的な欠落に変換するのにはどうしたら良いでしょうか？考え方を説明してください（Rの関数名を出す必要はありません）。

　  

## 明示的な欠落データへの変換
`tidyr`パッケージに用意されている`tidyr::complete`関数を使います。使い方はいたってシンプルでキーを指定することで、残りを欠損値として変換してくれます。
```{r}
df %>% 
  tidyr::complete(date = seq.Date(min(date), max(date), by = "day"))
```

　  
可視化するにあたって`NA`は$0$（ゼロ）に変換しておきたいので、オプション`fill`を使って以下のように指定します。この例の場合では`NA`と$0$は等価ですのでゼロに変換しても問題はありませんが、`NA`がゼロと等価でない場合にはむやみに変換しないように注意してください。
```{r}
df %>% 
  tidyr::complete(date = seq.Date(min(date), max(date), by = "day"),
                  fill = list(n = 0L))
```

　  
暗黙的な欠落を明示的な欠落に変換したことにより正しいグラフが描けました。
```{r}
df %>% 
  tidyr::complete(date = seq.Date(min(date), max(date), by = "day"),
                  fill = list(n = 0L)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = date, y = n)) + 
    ggplot2::geom_line()
```

　  

## 組み合わせデータの場合
`tidyr::complete`関数が威力を発揮するのは、組み合わせデータの場合です。関数のヘルプにあるコードで見てみましょう。このデータは本来であれば`group`と`item_id`の全ての組み合わせ（4通りの組み合わせ）があるべきデータです。
```{r}
df <- data.frame(
  group = c(1:2, 1),
  item_id = c(1:2, 2),
  item_name = c("a", "b", "b"),
  value1 = 1:3,
  value2 = 4:6
)
df
```

　  
明らかに暗黙的な欠落がありますので、`tidyr::complete`関数で、明示的な欠落値に変換してみます。指定はシンプルで組み合わせとなる`group`と`item_id`を指定するだけです。
```{r}
df %>% 
  tidyr::complete(group, item_id)
```

　  
よくよく見ると`item_id`と`item_name`は対になっているので、その場合は`tidyr::nesting`関数を用いて以下のように指定することで、`item_name`も同時に補完します。
```{r}
df %>% 
  tidyr::complete(group, tidyr::nesting(item_id, item_name))
```

　  
さらに`NA`が$0$（ゼロ）と等価であれば、前述のように`fill`オプションを使います。`fill`オプションはリスト型で指定しますので、複数の値があっても同時に指定することが可能です。
```{r}
df %>% 
  tidyr::complete(group, tidyr::nesting(item_id, item_name),
                  fill = list(value1 = 0L, value2 = 0L))
```

　  

# `NA`を任意の値に置換する
単に`NA`の値を任意の値に変換する場合には`tidyr::replace_na`関数を使います。ヘルプにあるコードを実行すると非常に単純な指定で変換できることが分かります。
```{r}
df <- data.frame(x = c(1, 2, NA), y = c("a", NA, "b"))
df
df %>% 
  replace_na(list(x = 0, y = "unknown"))
```

　  

# 組み合わせを生成する
以下のようなデータから考えうる変量（フィーチャー）の値の組み合わせを求めたい場合には`tidyr::expand`関数を用います。
```{r, echo=FALSE}
fruits <- tibble(
  type   = c("apple", "orange", "apple", "orange", "orange", "orange"),
  year   = c(2010, 2010, 2012, 2010, 2010, 2012),
  size  =  factor(
    c("XS", "S",  "M", "S", "S", "M"),
    levels = c("XS", "S", "M", "L")
  ),
  weights = rnorm(6, as.numeric(size) + 2)
)
fruits
```

　  
例えば、`type`と`size`の組み合わせを求める場合には以下のように指定します。
```{r}
fruits %>% 
  tidyr::expand(type, size)
```

　  
`size`に'L'があるのは`size`が因子型変数で4種類の水準をもっているからです。
```{r}
levels(fruits$size)
```

　  
存在するデータだけの組み合わせを求める場合には`tidyr::nesting`関数を組み合わせます。
```{r}
fruits %>% 
  tidyr::expand(tidyr::nesting(type, size))
```

以上
